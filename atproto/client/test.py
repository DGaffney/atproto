import asyncio
import os
from dataclasses import dataclass
from typing import Any, Optional, Tuple

import httpx


class Request:
    """Class for handling requests errors and working with httpx"""

    def __init__(self):
        self._httpx_client = ...

    def post(self):
        pass

    def get(self):
        pass


class ClientBase:
    """Low level methods are here"""

    def __init__(self, request=None):
        if request is None:
            request = Request()

        self._request = request

    @property
    def request(self):
        return self.request

    def invoke(self, nsid: str):
        print('invoke', nsid)
        # should be something like this:

        # but it requires work with parsed lexicon. I don't want to parse all lexicon each script run
        # we can resolve all necessary data during generation and place near of nsid

        # if is_post(resolve_http_method_by_nced(nsid)):
        #     self.request.post(...)
        # else:
        #     self.request.get(...)


@dataclass
class NamespaceBase:
    _client: 'ClientRaw'


@dataclass
class DefaultNamespace:
    """placeholder"""


# TODO(MarshalX): add support of records? namespaces with 5 const methods? CRUDL
# TODO(MarshalX): design data models (input, output, query params, request params (encoding + headers))

# GENERATED EXAMPLE


class IdentityNamespace(NamespaceBase):
    def resolve_handle(self):
        self._client.invoke('com.atproto.identity.resolveHandle')


@dataclass
class AtprotoNamespace(NamespaceBase):
    identity: IdentityNamespace = DefaultNamespace()

    def __post_init__(self):
        self.identity = IdentityNamespace(self._client)


@dataclass
class ComNamespace(NamespaceBase):
    atproto: AtprotoNamespace = DefaultNamespace()

    def __post_init__(self):
        self.atproto = AtprotoNamespace(self._client)


class ClientRaw(ClientBase):
    """AUTOGENERATED. Group all root namespaces"""

    com: ComNamespace

    def __init__(self):
        super().__init__()

        self.com = ComNamespace(self)


# END GENERATED EXAMPLE


class Client(ClientRaw):
    """High level methods are here"""

    def test(self):
        return self.com.atproto.identity.resolve_handle()

    def send_post(self, msg: str, img: bytes):
        """User-friendly method to call batch of methods like:

        blob_id = self.com.atproto.repo.upload_blob(img)
        post_id = self.app.app.bsky.feed.post.create(msg, img) # TODO(MarshalX): design records
        return post_id
        """


# EXAMPLE OF USAGE

client = Client()
# using high lvl methods
client.test()
client.send_post('hi', b'png')
# raw api calling
client.com.atproto.identity.resolve_handle()
exit(0)

# END EXAMPLE OF USAGE


ATP_BASE_URL = 'https://bsky.social/xrpc'


async def get_token(identifier: str, password: str) -> Tuple[str, str]:
    async with httpx.AsyncClient() as client:
        url = f'{ATP_BASE_URL}/com.atproto.server.createSession'
        res = await client.post(url, json={'identifier': identifier, 'password': password})
        if res.status_code == 200:
            content = res.json()
            return content['did'], content['accessJwt']

    raise ValueError('Can\'t get access token')


async def resolve_handle(handle: str, token: str) -> str:
    async with httpx.AsyncClient() as client:
        url = f'{ATP_BASE_URL}/com.atproto.identity.resolveHandle'
        res = await client.get(url, params={'handle': handle}, headers={'Authorization': f'Bearer {token}'})
        if res.status_code == 200:
            content = res.json()
            return content['did']

    raise ValueError('Can\'t get resolve handle')


async def main():
    did_expected, token = await get_token(os.environ['USERNAME'], os.environ['PASSWORD'])
    did_actual = await resolve_handle(os.environ['HANDLE'], token)

    assert did_expected == did_actual


if __name__ == '__main__':
    asyncio.get_event_loop().run_until_complete(main())
